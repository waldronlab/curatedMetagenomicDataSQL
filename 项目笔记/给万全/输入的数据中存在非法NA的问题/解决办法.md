# 解决办法

这一次是首次修改了规范，而不是修改数据。

修改之前，允许的值是“yes|no”，修改之后变成了“yes|no|NA”。

注意：“NA”是无效的意思。

# 修改波及的范围/影响

这一个很重要的信号：也就意味着将来的这个规范有可能比较频繁的变动。

我们在设计期间应该考虑将来如何应对这种频繁的变动。

# 复杂无止境

现在的规范相对简单，都存在与数据的矛盾。那么将来呢？

将来很有可能存在规范和自身自相矛盾的地方。

这仅仅是一种预感，并没有证据。

因为用户目前的规范，也是用数据来表示的(见数据库tsv.public."fieldsDef")。

所谓管中窥豹只见一斑，用户其它的数据都这样混乱，虽然规范没有暴露出矛盾，我们也得预先做好心理准备。

规范自相矛盾的地方，迟早会暴露出来。

# 固化程序的思想

我们的程序虽然源自规范(见数据库tsv.public."fieldsDef")，但是不能依赖于规范。

必须要固化下来，也就是规范(见数据库tsv.public."fieldsDef")调整的时候，我们的程序不能够自动的调整。

因为一旦哪天，哪个不懂的人一不小心修改了表示规范的数据(见数据库tsv.public."fieldsDef")，那系统就很有可能奔溃了。

# 手动的让我们的程序和规范保持同步

程序本身就是人工编写的，程序和规范的同步必然是手动的。

但是，编程的过程可以自动化一些。

所以，我们在源码中有个样本中心这个目录(sampleCenter)，其中有个比较变态的设计叫做“校验程序生成器(checkerGenerator)”。
它的主要功能就是读取，数据库中的规范，来自动生成校验程序。
它生成的校验程序名字是“FieldProcess”，其中只提供了一个外部函数就是

```typescript
export function check(json:object):void
```

这个函数看起来很特殊，根本没有返回值。为什么会这样呢？

因为如果校验失败，这个函数以异常的形式反馈原因，所以就不需要返回值了。
这也是为了并行同步调用时的安全考虑。







